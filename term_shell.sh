#!/bin/bash

# Set up prompt to include exit status
# The unicode symbol allow us to segregate prompt and commands from regular stderr
export PS1='âš˜ \[\033[01;32m\]\u@\h\[\033[00m\] - \[\033[01;34m\]\w\[\033[00m\]\nâš¡'
export BASH_SILENCE_DEPRECATION_WARNING=1
# capture the directory of the script
AITERM_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
export PYTHONPATH="$AITERM_DIR/src:$PYTHONPATH"

CHOICE_SYMBOL="ðŸ”˜"
QUESTION_SYMBOL="â“"

# Set up FIFO for stderr
rm -f /tmp/stderr_fifo_*
rm -f /tmp/stderr_dup_*
STDERR_FIFO="/tmp/stderr_fifo_$$"
STDERR_DUP="/tmp/stderr_dup_$$"
mkfifo "$STDERR_FIFO"
mkfifo "$STDERR_DUP"

# redirect stderr to fifo, and to python script
cat "$STDERR_FIFO" | python $AITERM_DIR/src/ai_term/shell/term_shell.py &
CAT_PID=$!
exec 2> "$STDERR_FIFO"

# send questions to AI
aiask() {
    python $AITERM_DIR/src/ai_term/shell/aiask.py "$*"
}

# ask AI to generate scripts
aiscript() {
    python $AITERM_DIR/src/ai_term/shell/aiscript.py "$*"
}

# execute command generated by AI
aicmd() {
    # if no args, print all commands
    if [ -z "$1" ]; then
        # Print a numbered list of commands
        awk '{print NR ". " $0}' /tmp/predicted_commands.txt
        # ask user to select a command
        read -p "$QUESTION_SYMBOL " selection
        cmd=$(sed -n "${selection}p" /tmp/predicted_commands.txt)
    else
        cmd=$(sed -n "${1}p" /tmp/predicted_commands.txt)
    fi

    # Confirm before executing
    read -p "$QUESTION_SYMBOL $cmd (y/n) " confirm
    if [[ $confirm != [yY] ]]; then
        echo "Command execution cancelled."
        return
    fi
    $cmd
}

# Function to clean up FIFO on exit
cleanup() {
    rm -f "$STDERR_FIFO"
    rm -f "$STDERR_DUP"
    kill $CAT_PID
    # kill $MONITOR_PID
    echo "Exiting"
}
trap cleanup EXIT



